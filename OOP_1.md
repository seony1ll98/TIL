# 프로그래밍 패러다임

## 절차 지향(PP)과 객체 지향(OOP)

- **절차 지향 프로그래밍(Procedural Programming)** :   
데이터를 '순차적으로' 처리하며, 함수와 로직을 중심으로 작성

- 특징   
1. 입력을 받고, 처리하고 결과를 내는 과정이 위에서 아래로 순차적으로 흐르는 형태
2. 순차적인 명령어 실행
3. 데이터와 함수가 분리되어 있음
4. 함수 호출의 흐름이 중요

- 한계   
1. 복잡성 증가 : 프로그램 규모가 커질수록 데이터와 함수의 관리가 어려움, 전역 변수의 증가로 인한 관리가 어려움
2. 유지보수 문제 : 코드 수정 시 영향 범위 파악이 어려움
---
- **객체 지향 프로그래밍(Object-Oriented Programming)** :   
클래스를 설계도(blueprint)처럼, 인스턴스를 실제 물건처럼 활용하는 프로그래밍

- 데이터(변수)와 함수(메서드)를 하나의 단위(객체)로 묶어서 조직적으로 관리   
(데이터와 메서드의 결합)

- 객체 지향 - "데이터가 살아나다" :   
객체 지향에서는 데이터와 메서드가 하나의 객체로 통합되어 스스로 기능을 수행하는 능동적 존재가 됨
    - 참고) 절차 지향과 객체 지향은 대조되는 개념이 아님

## 객체와 클래스

- 객체(Object) : 실제 존재하는 사물을 추상화한 것
    - 객체는 속성과 동작을 가진다
    1. 속성 : 변수 형태로 관리
    2. 동작 : 함수 형태로 관리

- 클래스(Class) : 객체를 만들기 위한 설계도,    
데이터와 기능을 함께 묶는 방법을 제공,   
 파이썬에서 `type`를 표기하는 방법

# Class 기초

- **클래스(Class) : 하나의 구조 안에 데이터(변수)와 기능(함수)를 함께 정의하여 관리하는 방법**

- **양식은 클래스, 실제 정보는 인스턴스**

## 클래스

- 클래스의 정의 : `Class` 키워드로 작성, 클래스 이름은 파스칼 케이스(Pascal Case) (ex. `class MyClass:`) 방식으로 작성
```python
class Person :
    def __init__(self, name, age):
        self.name = name
        self.age = age
    def introduce(self) :
        print(f'안녕하세요. 저는 {self.name}, 나이는 {self.age}살입니다.')
```

## 인스턴스

- **인스턴스(instance) : 클래스를 통해 생성된 객체**

- 클래스가 설계도라면, 인스턴스는 그 설계도로부터 실제로 만든 개별 물건에 해당한다.

## 클래스 vs 인스턴스

- 클래스가 설계 틀이라면, 실제 활동하는 개별 객체들은 이 틀에서 생성된 인스턴스이다.

- 즉, 클래스를 만드는 것은 곧 새로운 타입(`type`)을 만드는 행위

- 우리가 사용해왔던 데이터 타입은 사실 전부 클래스였다!
```python
name = 'Alice'
my_list = [1, 2, 3]

print(type(name)) # <class 'str'>
print(type(my_list)) # <class 'list'>
my_list.append(4)
```
- 하나의 객체는 특정 클래스의 인스턴스이다.

## 클래스의 구성 요소

1. 생성자 메서드   
- 인스턴스 생성 시 자동 호출되는 특별한 메서드
- `__init__`이라는 이름의 메서드로 정의
- 인스턴스 변수의 초기화 담당

2. 인스턴스 변수(속성)
- 각 인스턴스별 고유한 속성
- `self.(변수명)` 형태로 정의

3. 클래스 변수(속성)
- 모든 인스턴스가 공유하는 속성
- 클래스 내부에서 직접 정의

```python
class Circle:
    pi = 3.14 # 클래스 변수

    def __init__(self, radius): # 생성자 메서드
        self.radius = radius # 인스턴스 변수

# 인스턴스 생성
c1 = Circle(1)
c2 = Circle(2)

# 인스턴스 변수(속성) 접근
print(c1.radius)
print(c2.radius)

# 클래스 변수(공통 속성) 접근
print(c1.pi)
print(c2.pi)
```

## 클래스 변수와 인스턴스 변수

- 클래스 변수와 동일한 이름으로 인스턴스 변수 생성 시 클래스 변수가 아닌 인스턴스 변수에 먼저 참조하게 됨

```python
# 위의 예시에서 c1이 본인 인스턴스 변수 pi를 생성한다면?(좋지 않은 설계)
c1.pi = 100

print(c1.pi) # 100
print(Circle.pi) # 3.14

print(c2.pi) # 3.14
```

# Method

## 인스턴스 메서드

- 인스턴스의 상태를 조작하거나 동작을 수행
- 호출 주체 : 인스턴스

- 클래스 내부에 정의되는 메서드의 기본으로, 반드시 첫 번째 인자로 인스턴스 자신(`self`)을 받음
    - 참고) `self`는 매개변수 이름일 뿐이며 다른 이름으로 설정이 가능하지만, 다른 이름을 사용하지 않을 것을 강력히 권장
- 인스턴스의 속성에 접근하거나 변경 가능

- ex) 인스턴스 메서드 활용 예시

```python
class Counter:
    def __init__(self):
        self.count = 0

    # 인스턴스 메서드
    def increment(self):
        self.count += 1

# 인스턴스 메서드 호출
c1 = Counter()
c2 = Counter()
c1.increment()
print(c1.count) # 1
print(c2.count) # 0
```

- **생성자 메서드(constructor method)** : 인스턴스 객체가 생성될 때 자동으로 호출되는 메서드(인스턴스 변수들의 초기값을 설정)

- 사실 생략해도 내부적으로는 동작한다!

```python
class Person:
    # 생성자 메서드
    def __init__(self, name) :
        self.name = name
        print('인스턴스가 생성되었습니다')

    def greeting(self):
        print(f'안녕하세요 {self.name}입니다.')

p1 = Person('지민') # 인스턴스가 생성되었습니다.
p1.greeting() # 안녕하세요. 지민입니다.

Person.greeting(p1) # 안녕하세요. 지민입니다.
```

## 클래스 메서드
- 클래스 변수를 조작하거나 클래스 레벨의 동작을 수행
- `@classmethod` 데코레이터를 사용하여 정의
- 호출 시, 첫 번째 인자로 해당 메서드를 호출하는 클래스(`cls`)가 전달됨
    - 참고) `cls`는 매개변수 이름일 뿐이며 다른 이름으로 설정이 가능하지만, 다른 이름을 사용하지 않을 것을 강력히 권장
- 클래스를 인자로 받아 클래스 속성을 변경하거나 읽는 데 사용

- ex) 클래스 메서드 활용 예시
```python
class Person:
    population = 0

    def __init__(self, name):
        self.name = name

    # 클래스 메서드
    @classmethod
    def increase_population(cls) :
        cls.population += 1


# 인스턴스 생성
person1 = Person('Alice')
person2 = Person('Bob')

# 클래스 변수 접근
print(Person.population)  # 2
```

## 스태틱 메서드
- 클래스, 인스턴스와 상관없이 독립적으로 동작하는 메서드(단독적으로 활용)

- `@staticmethod` 데코레이터를 사용하여 정의

- 호출 시 자동으로 전달받는 인자가 없음
- 인스턴스나 클래스 속성에 직접 접근하지 않는, 도우미 함수와 비슷한 역할(단순한 역할을 수행)
- 호출 주체 : 클래스

- ex) 스태틱 메서드 활용 예시
```python
class MathUtils:
    # 정적 메서드
    # 클래스나 인스턴스에 의존하지 않고 독립적으로 동작
    # 정적 메서드는 클래스나 인스턴스의 상태를 변경하지 않음
    @staticmethod
    def add(a, b) :
        return a + b

# 정적 메서드 호출
print(MathUtils.add(3,5)) # 8
```

## 메서드 정리

1. 인스턴스 메서드 :   
인스턴스의 상태를 변경하거나, 특정 동작을 수행
2. 클래스 메서드 :   
인스턴스의 상태에 의존하지 않는 기능을 정의
클래스 변수를 조작하거나 클래스 레벨의 동작을 수행
3. 스태틱 메서드 :   
클래스 및 인스턴스와 관련이 없는 일반적인 기능을 수행

- 할 수 있다 != 써도 된다   
사실, 인스턴스와 클래스는 모든 메서드를 호출할 수 있다. 하지만,   
    - 클래스는 클래스 메서드와 스태틱 메서드만 사용하는 것이 바람직하다.
    - 인스턴스는 인스턴스 메서드만 사용하는 것이 바람직하다.

# 참고

## 클래스와 인스턴스 간 이름 공간
- 클래스를 정의하면, 클래스와 해당하는 이름 공간 생성
- 인스턴스를 만들면, 인스턴스 객체가 생성되고 독립적인 이름 공간 생성
- 인스턴스에서 특정 속성에 접근하면, 인스턴스 -> 클래스 순으로 탐색

## 매직 메서드
- Double underscore(`__`)가 있는, 특수한 동작을 위해 만들어진 인스턴스 메서드
- 특정 상황에서 자동으로 호출됨   
ex) `__str__(self)`

## 데코레이터
- 다른 함수의 코드를 유지한 채로 수정하거나 확장하기 위해 사용되는 함수

```python
# 데코레이터 정의
def my_decorator(func):
    def wrapper():
        # 함수 실행 전에 수행할 작업
        print('함수 실행 전')
        # 원본 함수 호출
        result = func()
        # 함수 실행 후에 수행할 작업
        print('함수 실행 후')
        return result

    return wrapper


# 데코레이터 사용
@my_decorator
def my_function():
    print('원본 함수 실행')


my_function()

"""
함수 실행 전
원본 함수 실행
함수 실행 후
"""
```

